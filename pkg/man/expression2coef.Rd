% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/expressions.R
\name{expression2coef}
\alias{expression2coef}
\title{\code{expression2coef} is an interpreter for a single null hypothesis}
\usage{
expression2coef(ex, vars, sh0, verbose = F, zerocheck = T)
}
\arguments{
\item{ex}{R expression describing the null hypothesis}

\item{vars}{Character vector of effect names}

\item{sh0}{Label of h0 as in ex = c('A greater B' = ' A - B >= 0 ' )}

\item{verbose}{Trace parser states and actions, if true}

\item{zerocheck}{Check for effects being near zero in terms of machine precision}
}
\value{
A list with the following elements:
        \itemize{
             \item  coef          Vector of effect coefficients
             \item  names         Vector of effect names
             \item  m             Right-hand side value (a numeric value of length 1)
             \item  alternative   One of: 'less' or 'greater' or 'two.sided'
             \item  lhs           Left-hand side terms
             \item  rhs           Right-hand side terms
        }
}
\description{
Extract the effect coefficients from an equation or inequation describing a single null hypothesis and
        also provide the rhs value.
}
\details{
Starting from the results of a call to \code{parse(text='some equation')},
         the function \code{expression2coef} gets called with an object of type expression passed
         in its parameter `ex`.

         Expressions in R are internally based on a tree structure, which can be mapped to a list of lists.

         Each entry of these recursive lists is then going to be inspected by the interaction
         of a pair of very concisely written functions:  \code{makeCodeWalker(..., handler, call, leaf)}
         and \code{walkCode(e, w = makeCodeWalker())}  with `e` representing the  symbol node
         to be processed. Both can be found in \pkg{base}. The walkCode function itself spans only a few lines:
         \preformatted{
           walkCode <-
           function ( e, w = makeCodeWalker() ) {
              if ( typeof(e) == 'language' ) {
                   if ( typeof([[e1]]) %in% c( 'symbol', 'character' ))
                   {
                      h <- w$handler(as.character(e[[1]]), w)
                      if (!is.null(h) )
                           h(e, w)
                      else w$call(e, w)
                   } else  w$call(e, w)
              } else w$leaf(e, w)
           }
         }
         There is also the \code{\link[codetools]{showTree}} utility which can print
         out something very close to a polish notatation of any expression by
         simply using makeCodeWalker's default implementation.

         Standing on the fundament laid by the codetools framework, a call to the
         core of an interpreter for arbitrary expressions will become
         straightforward:
         \preformatted{
         result <-
         walkCode( e = parse( text = ' (a - x ) * 2 >= 0 ' )[[1]],
                   w = makeCodeWalker( some helper functions ...,
                                       handler = function (v, w) { (...)},
                                       call    = function (v, w) { (...)},
                                       leaf    = function (v, w) { (...)}))
         }
         The symbol tree  for eqn{ ( a - x ) * 2 >= 0} would  look like this:
         \preformatted{
                     >=        <- node is addressed by as.list(exp[[1]])[1]
                    /  \
                   *    0      <- nodes are addressed by as.list(exp[[1]])[2:3]
                  / \
                 -   2
                / \
               a   x
         }
         So any node can be seen as the head of a recursive list. exp[[1]] would
         address the top level node named `>=` as well as all nodes attached to it.
         Symbol names provide the node labels. Terminal symbols like `a`, `x`, 2 and 0
         are called leafs.

         With the top node being represented by the symbol `>=`, \code{walkCode(`>=`, w)}
         would recursively visit all descendants of this node, with the first of the two subtrees
         being the left-hand and the right-hand side of the inequation.

         A node with leafs attached represents an operator. If \code{walkCode} sees such a node,
         it calls the top level function \code{handler(v, w)} with `v` being the symbol
         represented by the node, say `*`.

         \code{handler(`*`, w)} then dispatches a function specialised on that particular
         operator, which is \code{mul(v, w)} in our case. So \code{walkCode} calls
         \code{h(e, w)} with `h` actually being the function \code{mul(v , w)} and
         `e` or `v`  being  the symbol node `*` having  attached descendant nodes represented by
         the symbol nodes `-` and  the literal 2.

         From within \code{sub(`-`, w)}, \code{walkCode} would then recursively get
         called on the two leafs `a` and  `x`. Since both are terminal symbols,
         \code{walkCode}  would immediately call \code{leaf(e, w)} for each of them.

         \code{leaf(e , w)} would return e, but associated with a coefficient of 1.

         If \code{handler(v, w)} returns null for a particular operator or function name,
         the node and its subtree gets passed to \code{call(v, w)}, with the idea to transfer
         control to some external functions able to handle that node.

         Now, the other cornerstone of this implementation consists in binding a coefficcient
         to each node of the parse tree. For  \eqn{(a - x) * 2  >= 0}, this would look like
         a decorated christmas tree:
         \preformatted{
                            >= ~ coef 1
                           /  \
                 coef 1 ~ *    0 ~ coef 1
                         / \
               coef 1 ~ -   2 ~ coef 1
                       / \
             coef 1 ~ a   x ~ coef  1
         }
         Again, \code{walkCode(top, w )} will start by calling the \code{handler(v, w)},
         which will return a call to \code{eqn(`>=`, w)}

         \code{eqn(`>=`, w)}  in turn calls \code{walkCode} for the lhs and rhs side.
         On lhs, the next symbol will be `*`, so \code{walkCode} calls \code{handler(`*`, w)},
         which returns \code{mul(v, w)}

         When called, this function first runs \code{walkCode} again on all descendants of
         the `*` node . So the next operation will be \code{sub(`-`, w)}. Itself recursively
         calling \code{walkCode} on her own descandant will result in two calls to
         \code{leaf(v, w)} with `v` being `a` and `x`

         \code{leaf(v, w)} in turn is defined as a function which somehow associates
         a coefficient of 1 to each symbol `v` before returning it.

         Thus the descendants of the `*` node will be equivalent to the term \eqn{(a - x) * 2},
         representing the whole left-hand side of the inequation in our example.

         \code{mul(`*`, w)} will then be able to compute the lhs effect coefficents `a` and
         `x` by running two multiplications:
         \preformatted{
             coef(a) <- coef(a) * coef(2)
                        |         |
                        1         2

             coef(x) <- coef(x) * coef(2)
                        |         |
                       -1         2
         }
         The coefficents of `a`  and `x` had been computed before when \code{mul(v, w)} walked its two
         subtrees.  \code{walkCode} saw the `-` node and thus got the instruction from
         \code{handler(`-`, w)} to call \code{sub(`-`, w)}, which in turn got the two
         nodes `a` and `x` and set their coefficients that way:
         \preformatted{
             coef(a) <- coef(a)
                        |
                        1

             coef(x) <- coef(x) * - 1
                        |
                        1
         }
         So far the concept came along as an elegant solution. But there was a hidden problem
         in the implementation which didn't manifest itself simply because previously constructs
         like \eqn{ x - 2 * x == 0} were recognized and rejected. Therein, the effect `x`
         appears twice in different contexts. Supporting this by simply adding up the coefs
         of all occurences of  `x` as the last processing step appeared to be straightforward,
         except that it really wasn't that simple.

         For keeping track of coefs, coefficients were previously linked as an additional
         attribute to the symbol nodes of the tree returned by \code{\link[base]{parse}}. This
         is not very different from instances of S4 classes carrying around their slot values as
         attributes named like the slot names.

         Linking the coefficients as attributes to the variables and expressions they actually
         belong to appeared to be attractive as this spared the effort of inventing
         an explicit mechanism for keeping them in sync.

         However, a symbol like `x` is only a name refering operations on it to a certain
         memory region where its value gets stored. This region does not change when the
         reference associated with that region gets copied along by program actions.
         But within the same environment, all references carrying the same name also map
         to the same address, much like copied pointers or references in \verb{C} and
         \verb{C++} point or refer to the very same memory address.

         In the example above, the information hold by the \code{coef} attribute would be +1
         for the first `x1`. As soon as the next occurence of `x1` gets processed its
         coefficient would be set to -2. But then both occurences of `x1` are being associated
         with a coefficent of -2 and hence the sum of over all coefficients of both occurences of
         `x1` would become -4 instead of -1.

         The magic behind had already been told: while the attribute operation was performed on
         two different instances of the reference, both redirected the attribute operation to
         the very same memory area.

         The solution was to create a copy for every instance of all symbols by means of
         creating an instance of the \linkS4class{Effect} and \linkS4class{Symbol} classes
         in order to support all these corner cases correctly.

         Having solved all this, a quickly written test case \eqn{ 2*(x - 1) +3 == 0} uncovered
         yet another problem. With `x` being an effect, \eqn{ 2*(x - 1)} the
         \code{add(v, w)} and \code{sub(v, w)} function had to return a list of symbol
         nodes, containing both effects and literal elements at the same time.  Hence the class
         \linkS4class{Literal} was introduced to provide placeholder also for
         additive constants as they can not be folded together with effect symbols.

         \code{transform} and \code{merge} utilities running below the equation handler
         \code{eqn(v, w)} are thus finally able to add up all these coefficients, transfer the
         result to unique instances of the effect variable representing the left-hand side, and also
         sum up all literals which all together form the right-hand side value.
}
\note{
Implementation needs package \pkg{codetools}
}
\examples{
e1 <- parse(text = ' (x2 - x1) >= 1 + sin(pi/4) * ( 2*x3 - x4 ) ')
e2 <- parse(text = ' (x2 - x1) - sin(pi/4) * ( 2*x3 - x4 ) -1 >= 0 ')

r1 <- multcomp:::expression2coef( e1, c('x1', 'x2', 'x3', 'x4'), 'h0.1a' )
r2 <- multcomp:::expression2coef( e2, c('x1', 'x2', 'x3', 'x4'), 'h0.1b' )

stopifnot( all.equal( r1$coef, r2$coef ) )
stopifnot( all.equal( r1$m, r2$m ) )
}
\seealso{
chrlinfct2matrix
}

